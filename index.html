<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>unit 3</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>unit 3</h1><br/><p></p><p><strong><h2> TREE</h2></strong><a name="h2-1"></a><a name="tree"></a></p><p></p><p>  A tree data structure is defined as a collection of objects or entities known as nodes that are linked together to represent or simulate hierarchy.</p><p></p><p>A tree data structure is a non-linear data structure because it does not store in a sequential manner. It is a hierarchical structure as elements in a Tree are arranged in multiple levels.</p><p></p><p>In the Tree data structure, the topmost node is known as a root node. Each node contains some data, and data can be of any type.</p><p></p><p><h2>Tree Terminology</h2><a name="h2-2"></a></p><p><ul><li><strong>Root:</strong> The root node is the topmost node in the tree hierarchy. In other words, the root node is the one that doesn&#39;t have any parent. In the above structure, node numbered 1 is <strong>the root node of the tree.</strong> If a node is directly linked to some other node, it would be called a parent-child relationship.</li><li><strong>Child node:</strong> If the node is a descendant of any node, then the node is known as a child node.</li><li><strong>Parent:</strong> If the node contains any sub-node, then that node is said to be the parent of that sub-node.</li><li><strong>Sibling:</strong> The nodes that have the same parent are known as siblings.</li><li><strong>Leaf Node:-</strong> The node of the tree, which doesn&#39;t have any child node, is called a leaf node. A leaf node is the bottom-most node of the tree. There can be any number of leaf nodes present in a general tree. Leaf nodes can also be called external nodes.</li><li><strong>Internal nodes:</strong> A node has atleast one child node known as an <em><strong>internal</strong></em></li><li><strong>Ancestor node:-</strong> An ancestor of a node is any predecessor node on a path from the root to that node. The root node doesn&#39;t have any ancestors. In the tree shown in the above image, nodes 1, 2, and 5 are the ancestors of node 10.</li><li><strong>Descendant:</strong> The immediate successor of the given node is known as a descendant of a node. In the above figure, 10 is the descendant of node 5.</li></ul></p><p></p><p><strong>Recursive data structure:</strong> The tree is also known as a <em><strong>recursive data structure</strong></em>. A tree can be defined as recursively because the distinguished node in a tree data structure is known as a <em><strong>root node</strong></em>. The root node of the tree contains a link to all the roots of its subtrees. The left subtree is shown in the yellow color in the below figure, and the right subtree is shown in the red color. The left subtree can be further split into subtrees shown in three different colors. Recursion means reducing something in a self-similar manner. So, this recursive property of the tree data structure is implemented in various applications.</p><p><a href="https://images.javatpoint.com/ds/images/tree3.png"><img src="images/17-1.png" alt="images/17-1.png" /></a></p><p></p><p><strong>Number of edges:</strong> If there are n nodes, then there would n-1 edges.</p><p></p><p><strong>Depth of node x:</strong> The depth of node x can be defined as the length of the path from the root to the node x. One edge contributes one-unit length in the path. So, the depth of node x can also be defined as the number of edges between the root node and the node x. The root node has 0 depth.</p><p></p><p></p><p><strong><h3>Implementation of Tree</h3></strong><a name="h3-1"></a></p><p></p><p>The tree data structure can be created by creating the nodes dynamically with the help of the pointers. The node contains three fields. The second field stores the data; the first field stores the address of the left child, and the third field stores the address of the right child.</p><p></p><p><strong><h3>Application of Tree</h3></strong><a name="h3-2"></a></p><p></p><p> <strong>the file system:</strong> The file system stored on the disc drive, the file and folder are in the form of the naturally hierarchical data and stored in the form of trees.</p><p></p><p><strong>Trie:</strong> It is a special kind of tree that is used to store the dictionary.</p><p></p><p><strong>Heap:</strong> It is also a tree data structure implemented using arrays.</p><p></p><p><strong>B-Tree and B+Tree:</strong> B-Tree and B+Tree are the tree data structures used to implement indexing in databases.</p><p></p><p><strong>Routing table:</strong> The tree data structure is also used to store the data in routing tables in the routers.</p><p></p><p></p><p><strong><h3>Types of Tree data structure</h3></strong><a name="h3-3"></a></p><p></p><p><strong>General tree:</strong> • <strong>General tree:</strong> The general tree is one of the types of tree data structure. In the general tree, a node can have either 0 or maximum n number of nodes. There is no restriction imposed on the degree of the node (the number of nodes that a node can contain). The topmost node in a general tree is known as a root node. The children of the parent node are known as <em><strong>subtrees</strong></em>.</p><p><a href="https://images.javatpoint.com/ds/images/types-of-tree1.png"><img src="images/17-2.png" alt="images/17-2.png" /></a></p><p>There can be <em><strong>n</strong></em> number of subtrees in a general tree. In the general tree, the subtrees are unordered as the nodes in the subtree cannot be ordered.</p><p>Every non-empty tree has a downward edge, and these edges are connected to the nodes known as <em><strong>child nodes</strong></em>. The root node is labeled with level 0. The nodes that have the same parent are known as <em><strong>siblings</strong></em>.</p><p></p><p><h2>Binary Tree</h2><a name="h2-3"></a></p><p></p><p>Binary Tree: The Binary tree means that the node can have maximum two children. Here, binary name itself suggests that &#39;two&#39;; therefore, each node can have either 0, 1 or 2 children.</p><p></p><p>Properties of Binary Tree<ul><li>At each level of i, the maximum number of nodes is 2i.</li></ul></p><p><ul><li>The minimum number of nodes possible at height h is equal to <strong>h+1</strong>.</li></ul></p><p><ul><li>The height of the tree is defined as the longest path from the root node to the leaf node.</li></ul></p><p><ul><li>If the number of nodes is minimum, then the height of the tree would be maximum.</li></ul></p><p></p><p><strong><span style="color:#030095;"></span></strong></p><p><strong><span style="color:#030095;"></span></strong><strong><h3>Types of Binary Tree</h3></strong><a name="h3-4"></a></p><p><ol><li>1. <strong><h4>1. Full/ proper/ strict Binary tree</h4></strong></li></ol><a name="h4-1"></a></p><p></p><p>the tree in which each node must contain 2 children except the leaf nodes.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/types-of-binary-tree.png"><img src="images/17-3.png" alt="images/17-3.png" /></a></p><p><ol><li>2. <strong><h4>2. Complete Binary Tree</h4></strong></li></ol><a name="h4-2"></a></p><p></p><p> The complete binary tree is a tree in which all the nodes are completely filled except the last level. In the last level, all the nodes must be as left as possible. In a complete binary tree, the nodes should be added from the left.</p><p></p><p> <a href="https://images.javatpoint.com/ds/images/types-of-binary-tree2.png"><img src="images/17-4.png" alt="images/17-4.png" /></a></p><p><ol><li>4. <h4>4. </h4><strong><h4>Perfect Binary Tree</h4></strong></li></ol><a name="h4-3"></a></p><p></p><p>A tree is a perfect binary tree if all the internal nodes have 2 children, and all the leaf nodes are at the same level.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/types-of-binary-tree3.png"><img src="images/17-5.png" alt="images/17-5.png" /></a></p><p><ol><li>5. <h4>5. </h4><strong><h4>Degenerate Binary Tree</h4></strong></li></ol><a name="h4-4"></a></p><p></p><p>The degenerate binary tree is a tree in which all the internal nodes have only one children.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/types-of-binary-tree5.png"><img src="images/17-6.png" alt="images/17-6.png" /></a><span style="background-color:#ffffff;">    </span><a href="https://images.javatpoint.com/ds/images/types-of-binary-tree6.png"><img src="images/17-7.png" alt="images/17-7.png" /></a></p><p><ol><li>6. <h4>6. </h4><strong><h4>Balanced Binary Tree</h4></strong></li></ol><a name="h4-5"></a></p><p></p><p>The balanced binary tree is a tree in which both the left and right trees differ by atmost 1. For example, <em><strong>AVL</strong></em> and <em><strong>Red-Black trees</strong></em> are balanced binary tree.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/types-of-binary-tree7.png"><img src="images/17-8.png" alt="images/17-8.png" /></a></p><p></p><p><strong><h4>Binary Tree Implementation</h4></strong><a name="h4-6"></a></p><p></p><p>A Binary tree is implemented with the help of pointers. The first node in the tree is represented by the root pointer. Each node in the tree consists of three parts, i.e., data, left pointer and right pointer. To create a binary tree, we first need to create the node. We will create the node of user-defined as shown below:</p><p></p><p></p><p><span style="indent:2;"> </span><div class="codebox"><pre><span style="color:#a52a2a;font-weight:700">struct</span> node  <br /> {  <br />    <span style="color:#2e8b57;font-weight:700">int</span> data,  <br />    <span style="color:#a52a2a;font-weight:700">struct</span> node *left, *right;  <br /> }  </pre></div></p><p></p><p></p><p>In the above structure, <strong>data</strong> is the value, <strong>left pointer</strong> contains the address of the left node, and <strong>right pointer</strong> contains the address of the right node.</p><p></p><p><strong><h2>Binary Search Tree</h2></strong><a name="h2-4"></a></p><p></p><p>A binary search tree follows some order to arrange the elements. In a Binary search tree, the value of left node must be smaller than the parent node, and the value of right node must be greater than the parent node. This rule is applied recursively to the left and right subtrees of the root.<a name="h3-7"></a></p><p></p><p></p><p><h4>Advantages of Binary search tree</h4><a name="h4-7"></a></p><p><ul><li>Searching an element in the Binary search tree is easy as we always have a hint that which subtree has the desired element.</li></ul></p><p><ul><li>As compared to array and linked lists, insertion and deletion operations are faster in BST.</li></ul></p><p></p><p></p><p><h4>Example of creating a binary search tree</h4><a name="h4-8"></a></p><p>Now, let&#39;s see the creation of binary search tree using an example.<a name="h3-9"></a></p><p>Suppose the data elements are <strong>- 45, 15, 79, 90, 10, 55, 12, 20, 50</strong><a name="h3-10"></a><ul><li>First, we have to insert <strong>45</strong> into the tree as the root of the tree.</li><li>Then, read the next element; if it is smaller than the root node, insert it as the root of the left subtree, and move to the next element.</li><li>Otherwise, if the element is larger than the root node, then insert it as the root of the right subtree.</li></ul></p><p></p><p>Now, let&#39;s see the process of creating the Binary search tree using the given data element. The process of creating the BST is shown below -<a name="h3-11"></a></p><p><strong>Step 1 - Insert 45.</strong><a name="h3-12"></a></p><p><a href="https://images.javatpoint.com/ds/images/binary-search-tree3.png"><img src="images/17-9.png" alt="images/17-9.png" /></a></p><p><strong><span style="indent:2;">Step 2 - Insert 15.</span></strong><a name="h3-13"></a></p><p>As 15 is smaller than 45, so insert it as the root node of the left subtree.<a name="h3-14"></a></p><p><a href="https://images.javatpoint.com/ds/images/binary-search-tree4.png"><img src="images/17-10.png" alt="images/17-10.png" /></a><strong>Step 3 - Insert 79.</strong></p><p>As 79 is greater than 45, so insert it as the root node of the right subtree.<a name="h3-15"></a></p><p><a href="https://images.javatpoint.com/ds/images/binary-search-tree5.png"><img src="images/17-11.png" alt="images/17-11.png" /></a><strong>Step 4 - Insert 90.</strong></p><p>90 is greater than 45 and 79, so it will be inserted as the right subtree of 79.<a name="h3-16"></a></p><p><a href="https://images.javatpoint.com/ds/images/binary-search-tree6.png"><img src="images/17-12.png" alt="images/17-12.png" /></a><strong>Step 5 - Insert 10.</strong></p><p>10 is smaller than 45 and 15, so it will be inserted as a left subtree of 15.<a name="h3-17"></a></p><p><a href="https://images.javatpoint.com/ds/images/binary-search-tree7.png"><img src="images/17-13.png" alt="images/17-13.png" /></a><strong>Step 6 - Insert 55.</strong></p><p>55 is larger than 45 and smaller than 79, so it will be inserted as the left subtree of 79.<a name="h3-18"></a></p><p><a href="https://images.javatpoint.com/ds/images/binary-search-tree8.png"><img src="images/17-14.png" alt="images/17-14.png" /></a><strong>Step 7 - Insert 12.</strong></p><p>12 is smaller than 45 and 15 but greater than 10, so it will be inserted as the right subtree of 10.<a name="h3-19"></a></p><p><a href="https://images.javatpoint.com/ds/images/binary-search-tree9.png"><img src="images/17-15.png" alt="images/17-15.png" /></a><strong>Step 8 - Insert 20.</strong></p><p>20 is smaller than 45 but greater than 15, so it will be inserted as the right subtree of 15.<a name="h3-20"></a></p><p><a href="https://images.javatpoint.com/ds/images/binary-search-tree10.png"><img src="images/17-16.png" alt="images/17-16.png" /></a><strong>Step 9 - Insert 50.</strong></p><p>50 is greater than 45 but smaller than 79 and 55. So, it will be inserted as a left subtree of 55.<a name="h3-21"></a></p><p><a href="https://images.javatpoint.com/ds/images/binary-search-tree11.png"><img src="images/17-17.png" alt="images/17-17.png" /></a></p><p></p><p></p><p></p><p><h4>Searching in Binary search tree</h4><a name="h4-9"></a></p><p>Searching means to find or locate a specific element or node in a data structure. In Binary search tree, searching a node is easy because elements in BST are stored in a specific order. The steps of searching a node in Binary Search tree are listed as follows -<a name="h3-22"></a><ol><li>First, compare the element to be searched with the root element of the tree.</li><li>If root is matched with the target element, then return the node&#39;s location.</li><li>If it is not matched, then check whether the item is less than the root element, if it is smaller than the root element, then move to the left subtree.</li><li>If it is larger than the root element, then move to the right subtree.</li><li>Repeat the above procedure recursively until the match is found.</li><li>If the element is not found or not present in the tree, then return NULL.</li></ol></p><p>Now, let&#39;s understand the searching in binary tree using an example. We are taking the binary search tree formed above. Suppose we have to find node 20 from the below tree.<a name="h3-23"></a></p><p><strong>Step1:</strong><a name="h3-24"></a></p><p><a href="https://images.javatpoint.com/ds/images/binary-search-tree12.png"><img src="images/17-18.png" alt="images/17-18.png" /></a></p><p></p><p><strong>Step2:</strong><a name="h3-25"></a></p><p><a href="https://images.javatpoint.com/ds/images/binary-search-tree13.png"><img src="images/17-19.png" alt="images/17-19.png" /></a></p><p></p><p><strong>Step3:</strong><a name="h3-26"></a></p><p><a href="https://images.javatpoint.com/ds/images/binary-search-tree14.png"><img src="images/17-20.png" alt="images/17-20.png" /></a></p><p></p><p>Algorithm to search an element in Binary search tree<a name="h3-27"></a></p><p></p><p></p><p></p><p><div class="codebox"><pre><span style="color:#ff00ff;font-weight:400">1.</span> Search (root, item)  <br /><span style="color:#ff00ff;font-weight:400">2.</span> Step <span style="color:#ff00ff;font-weight:400">1</span> - <span style="color:#a52a2a;font-weight:700">if</span> (item = root → data) or (root = <span style="color:#ff00ff;font-weight:400">NULL</span>)  <br /><span style="color:#ff00ff;font-weight:400">3.</span> <span style="color:#a52a2a;font-weight:700">return</span> root  <br /><span style="color:#ff00ff;font-weight:400">4.</span> <span style="color:#a52a2a;font-weight:700">else</span> <span style="color:#a52a2a;font-weight:700">if</span> (item &lt; root → data)  <br /><span style="color:#ff00ff;font-weight:400">5.</span> <span style="color:#a52a2a;font-weight:700">return</span> Search(root → left, item)  <br /><span style="color:#ff00ff;font-weight:400">6.</span> <span style="color:#a52a2a;font-weight:700">else</span>  <br /><span style="color:#ff00ff;font-weight:400">7.</span> <span style="color:#a52a2a;font-weight:700">return</span> Search(root → right, item)  <br /><span style="color:#ff00ff;font-weight:400">8.</span> END <span style="color:#a52a2a;font-weight:700">if</span>  <br /><span style="color:#ff00ff;font-weight:400">9.</span> Step <span style="color:#ff00ff;font-weight:400">2</span> - END  </pre></div></p><p></p><p></p><p></p><p></p><p><ol><li>1. <h4>1. Time Complexity</h4></li></ol><a name="h4-10"></a></p><p><table class="table"><tr><th>Operations</th><th>Best case time complexity</th><th>Average case time complexity</th><th>Worst case time complexity</th></tr><tr><td>Insertion</td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td></tr><tr><td>Deletion</td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td></tr><tr><td>Search</td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td></tr></table></p><p></p><p>Where &#39;n&#39; is the number of nodes in the given tree.</p><p><ol><li>2. <h4>2. Space Complexity</h4></li></ol><a name="h4-11"></a></p><p><table class="table"><tr><th>Operations</th><th>Space complexity</th></tr><tr><td>Insertion</td><td>O(n)</td></tr><tr><td>Deletion</td><td>O(n)</td></tr><tr><td>Search</td><td>O(n)</td></tr></table></p><p></p><p>The space complexity of all operations of Binary search tree is O(n)</p><p></p><p><strong><h4>Traversal in Binary Search Tree</h4></strong><a name="h4-12"></a></p><p></p><p></p><p></p><p></p><p><h2>A V L   T r e e</h2><a name="h2-5"></a></p><p></p><p>AVL Tree is invented by GM Adelson - Velsky and EM Landis in 1962. The tree is named AVL in honour of its inventors. AVL Tree is invented by GM Adelson - Velsky and EM Landis in 1962. The tree is named AVL in honour of its inventors.<a name="h3-28"></a></p><p></p><p></p><p><h4>Balance Factor (k) = height (left(k)) - height (right(k))</h4><a name="h4-13"></a></p><p></p><p>If balance factor of any node is 1, it means that the left sub-tree is one level higher than the right sub-tree.</p><p>If balance factor of any node is 0, it means that the left sub-tree and right sub-tree contain equal height.</p><p>If balance factor of any node is -1, it means that the left sub-tree is one level lower than the right sub-tree.</p><p></p><p></p><p><h4>Complexity</h4><a name="h4-14"></a></p><p><table class="table"><tr><th>Algorithm</th><th>Average case</th><th>Worst case</th></tr><tr><td>Space</td><td>o(n)</td><td>o(n)</td></tr><tr><td>Search</td><td>o(log n)</td><td>o(log n)</td></tr><tr><td>Insert</td><td>o(log n)</td><td>o(log n)</td></tr><tr><td>Delete</td><td>o(log n)</td><td>o(log n)</td></tr></table></p><p></p><p><h4>Operations on AVL tree</h4><a name="h4-15"></a></p><p>Due to the fact that, AVL tree is also a binary search tree therefore, all the operations are performed in the same way as they are performed in a binary search tree. Searching and traversing do not lead to the violation in property of AVL tree. However, insertion and deletion are the operations which can violate this property and therefore, they need to be revisited.</p><p><table class="table"><tr><th>SN</th><th>Operation</th><th>Description</th></tr><tr><td>1</td><td>Insertion</td><td>Insertion in AVL tree is performed in the same way as it is performed in a binary search tree. However, it may lead to violation in the AVL tree property and therefore the tree may need balancing. The tree can be balanced by applying rotations.</td></tr><tr><td>2</td><td>Deletion</td><td>Deletion can also be performed in the same way as it is performed in a binary search tree. Deletion may also disturb the balance of the tree therefore, various types of rotations are used to rebalance the tree.</td></tr></table></p><p></p><p></p><p><h4>AVL Rotations</h4><a name="h4-16"></a></p><p>We perform rotation in AVL tree only in case if Balance Factor is other than <strong>-1, 0, and 1</strong>. There are basically four types of rotations which are as follows:<ol><li>L L rotation: Inserted node is in the left subtree of left subtree of A</li><li>R R rotation : Inserted node is in the right subtree of right subtree of A</li><li>L R rotation : Inserted node is in the right subtree of left subtree of A</li><li>R L rotation : Inserted node is in the left subtree of right subtree of A</li></ol></p><p>Where node A is the node whose balance Factor is other than -1, 0, 1.</p><p>The first two rotations LL and RR are single rotations and the next two rotations LR and RL are double rotations. For a tree to be unbalanced, minimum height must be at least 2, Let us understand each rotation</p><p><ol><li>1. <h5>1. RR Rotation</h5></li></ol><a name="h5-1"></a></p><p>When BST becomes unbalanced, due to a node is inserted into the right subtree of the right subtree of A, then we perform RR rotation, <a href="https://www.javatpoint.com/rr-rotation-in-avl-tree">RR rotation</a> is an anticlockwise rotation, which is applied on the edge below a node having balance factor -2</p><p><a href="https://images.javatpoint.com/ds/images/avl-tree.jpg"><img src="images/17-21.png" alt="images/17-21.png" /></a>In above example, node A has balance factor -2 because a node C is inserted in the right subtree of A right subtree. We perform the RR rotation on the edge below A.</p><p><ol><li>2. <h5>2. LL Rotation</h5></li></ol><a name="h5-2"></a></p><p>When BST becomes unbalanced, due to a node is inserted into the left subtree of the left subtree of C, then we perform LL rotation, <a href="https://www.javatpoint.com/ll-rotation-in-avl-tree">LL rotation</a> is clockwise rotation, which is applied on the edge below a node having balance factor 2.</p><p><img src="images/17-22.png" alt="images/17-22.png" /></p><p></p><p><ol><li>3. <h5>3. LR Rotation</h5></li></ol><a name="h5-3"></a></p><p> Double rotations are bit tougher than single rotation which has already explained above. LR rotation = RR rotation + LL rotation, i.e., first RR rotation is performed on subtree and then LL rotation is performed on full tree, by full tree we mean the first node from the path of inserted node whose balance factor is other than -1, 0, or 1.</p><p> </p><p><ol><li>4. <h5>4. RL Rotation</h5></li></ol><a name="h5-4"></a></p><p></p><p>That double rotations are bit tougher than single rotation which has already explained above. R L rotation = LL rotation + RR rotation, i.e., first LL rotation is performed on subtree and then RR rotation is performed on full tree, by full tree we mean the first node from the path of inserted node whose balance factor is other than -1, 0, or 1.</p><p></p><p></p><p><h2>B-tree</h2><a name="h2-6"></a></p><p></p><p> Tree is a specialized m-way tree that can be widely used for disk access. A B-Tree of order m can have at most m-1 keys and m children. One of the main reason of using B3 tree is its capability to store large number of keys in a single node and large key values by keeping the height of the tree relatively small.</p><p>A B tree of order m contains all the properties of an M way tree. In addition, it contains the following properties.<ol><li>Every node in a B-Tree contains at most m children.</li><li>Every node in a B-Tree except the root node and the leaf node contain at least m/2 children.</li><li>The root nodes must have at least 2 nodes.</li><li>All leaf nodes must be at the same level.</li></ol></p><p>It is not necessary that, all the nodes contain the same number of children but, each node must have m/2 number of nodes.</p><p>A B tree of order 4 is shown in the following image.</p><p><img src="images/17-23.png" alt="images/17-23.png" /></p><p></p><p>While performing some operations on B Tree, any property of B Tree may violate such as number of minimum children a node can have. To maintain the properties of B Tree, the tree may split or join.</p><p></p><p><h3>Operations</h3><a name="h3-5"></a></p><p></p><p><h4>Searching :</h4><a name="h4-17"></a></p><p>Searching in B Trees is similar to that in Binary search tree. For example, if we search for an item 49 in the following B Tree. The process will something like following :<ol><li>Compare item 49 with root node 78. since 49 &lt; 78 hence, move to its left sub-tree.</li><li>Since, 40&lt;49&lt;56, traverse right sub-tree of 40.</li><li>49&gt;45, move to right. Compare 49.</li><li>match found, return.</li></ol></p><p>Searching in a B tree depends upon the height of the tree. The search algorithm takes O(log n) time to search any element in a B tree.</p><p><a href="https://images.javatpoint.com/ds/images/b-tree-searching.png"><img src="images/17-24.png" alt="images/17-24.png" /></a></p><p></p><p><h4>Inserting</h4><a name="h4-18"></a></p><p>Insertions are done at the leaf node level. The following algorithm needs to be followed in order to insert an item into B Tree.<ol><li>Traverse the B Tree in order to find the appropriate leaf node at which the node can be inserted.</li><li>If the leaf node contain less than m-1 keys then insert the element in the increasing order.</li><li>Else, if the leaf node contains m-1 keys, then follow the following steps.</li><li>Insert the new element in the increasing order of elements.</li><li>Split the node into the two nodes at the median.</li><li>Push the median element upto its parent node.</li><li>If the parent node also contain m-1 number of keys, then split it too by following the same steps.</li></ol></p><p></p><p><strong>Example:</strong></p><p>Insert the node 8 into the B Tree of order 5 shown in the following image.</p><p><a href="https://images.javatpoint.com/ds/images/b-tree-inserting.png"><img src="images/17-25.png" alt="images/17-25.png" /></a></p><p>8 will be inserted to the right of 5, therefore insert 8.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-tree-inserting2.png"><img src="images/17-26.png" alt="images/17-26.png" /></a></p><p>The node, now contain 5 keys which is greater than (5 -1 = 4 ) keys. Therefore split the node from the median i.e. 8 and push it up to its parent node shown as follows.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-tree-inserting3.png"><img src="images/17-27.png" alt="images/17-27.png" /></a></p><p></p><p><h4>Deletion</h4><a name="h4-19"></a></p><p>Deletion is also performed at the leaf nodes. The node which is to be deleted can either be a leaf node or an internal node. Following algorithm needs to be followed in order to delete a node from a B tree.<ol><li>Locate the leaf node.</li><li>If there are more than m/2 keys in the leaf node then delete the desired key from the node.</li><li>If the leaf node doesn&#39;t contain m/2 keys then complete the keys by taking the element from eight or left sibling.</li><li>If the left sibling contains more than m/2 elements then push its largest element up to its parent and move the intervening element down to the node where the key is deleted.</li><li>If the right sibling contains more than m/2 elements then push its smallest element up to the parent and move intervening element down to the node where the key is deleted.</li></ol></p><p><ul><li>If neither of the sibling contain more than m/2 elements then create a new leaf node by joining two leaf nodes and the intervening element of the parent node.</li><li>If parent is left with less than m/2 nodes then, apply the above process on the parent too.</li></ul></p><p>If the the node which is to be deleted is an internal node, then replace the node with its in-order successor or predecessor. Since, successor or predecessor will always be on the leaf node hence, the process will be similar as the node is being deleted from the leaf node.</p><p><strong>Example 1</strong></p><p>Delete the node 53 from the B Tree of order 5 shown in the following figure.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-tree-deletion.png"><img src="images/17-28.png" alt="images/17-28.png" /></a></p><p>53 is present in the right child of element 49. Delete it.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-tree-deletion2.png"><img src="images/17-29.png" alt="images/17-29.png" /></a></p><p>Now, 57 is the only element which is left in the node, the minimum number of elements that must be present in a B tree of order 5, is 2. it is less than that, the elements in its left and right sub-tree are also not sufficient therefore, merge it with the left sibling and intervening element of parent i.e. 49.</p><p>The final B tree is shown as follows.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-tree-deletion3.png"><img src="images/17-30.png" alt="images/17-30.png" /></a></p><p></p><p><h3>Application of B tree</h3><a name="h3-6"></a></p><p>B tree is used to index the data and provides fast access to the actual data stored on the disks since, the access to value stored in a large database that is stored on a disk is a very time consuming process.</p><p>Searching an un-indexed and unsorted database containing n key values needs O(n) running time in worst case. However, if we use B Tree to index this database, it will be searched in O(log n) time in worst case.</p><p></p><p></p><p><h2>B+ Tree</h2><a name="h2-7"></a></p><p>B+ Tree is an extension of B Tree which allows efficient insertion, deletion and search operations.</p><p>In B Tree, Keys and records both can be stored in the internal as well as leaf nodes. Whereas, in B+ tree, records (data) can only be stored on the leaf nodes while internal nodes can only store the key values.</p><p>The leaf nodes of a B+ tree are linked together in the form of a singly linked lists to make the search queries more efficient.</p><p>B+ Tree are used to store the large amount of data which can not be stored in the main memory. Due to the fact that, size of main memory is always limited, the internal nodes (keys to access records) of the B+ tree are stored in the main memory whereas, leaf nodes are stored in the secondary memory.</p><p>The internal nodes of B+ tree are often called index nodes. A B+ tree of order 3 is shown in the following figure.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-plus-tree.png"><img src="images/17-31.png" alt="images/17-31.png" /></a></p><p><h3>Advantages of B+ Tree</h3><a name="h3-7"></a><ol><li>Records can be fetched in equal number of disk accesses.</li><li>Height of the tree remains balanced and less as compare to B tree.</li><li>We can access the data stored in a B+ tree sequentially as well as directly.</li><li>Keys are used for indexing.</li><li>Faster search queries as the data is stored only on the leaf nodes.</p><p></li></ol><a href="https://images.javatpoint.com/ds/images/b-plus-tree-advantages.jpg"><img src="images/17-32.png" alt="images/17-32.png" /></a></p><p><h3>B Tree VS B+ Tree</h3><a name="h3-8"></a></p><p><table class="table"><tr><th>SN</th><th>B Tree</th><th>B+ Tree</th></tr><tr><td>1</td><td>Search keys can not be repeatedly stored.</td><td>Redundant search keys can be present.</td></tr><tr><td>2</td><td>Data can be stored in leaf nodes as well as internal nodes</td><td>Data can only be stored on the leaf nodes.</td></tr><tr><td>3</td><td>Searching for some data is a slower process since data can be found on internal nodes as well as on the leaf nodes.</td><td>Searching is comparatively faster as data can only be found on the leaf nodes.</td></tr><tr><td>4</td><td>Deletion of internal nodes are so complicated and time consuming.</td><td>Deletion will never be a complexed process since element will always be deleted from the leaf nodes.</td></tr><tr><td>5</td><td>Leaf nodes can not be linked together.</td><td>Leaf nodes are linked together to make the search operations more efficient.</td></tr></table></p><p></p><p><h3>Insertion in B+ Tree</h3><a name="h3-9"></a></p><p><strong>Step 1:</strong> Insert the new node as a leaf node</p><p><strong>Step 2:</strong> If the leaf doesn&#39;t have required space, split the node and copy the middle node to the next index node.</p><p><strong>Step 3:</strong> If the index node doesn&#39;t have required space, split the node and copy the middle element to the next index page.</p><p></p><p>Example :</p><p>Insert the value 195 into the B+ tree of order 5 shown in the following figure.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-plus-tree-insertion.png"><img src="images/17-33.png" alt="images/17-33.png" /></a></p><p>195 will be inserted in the right sub-tree of 120 after 190. Insert it at the desired position.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-plus-tree-insertion2.png"><img src="images/17-34.png" alt="images/17-34.png" /></a></p><p>The node contains greater than the maximum number of elements i.e. 4, therefore split it and place the median node up to the parent.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-plus-tree-insertion3.png"><img src="images/17-35.png" alt="images/17-35.png" /></a></p><p>Now, the index node contains 6 children and 5 keys which violates the B+ tree properties, therefore we need to split it, shown as follows.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-plus-tree-insertion4.png"><img src="images/17-36.png" alt="images/17-36.png" /></a></p><p></p><p><h3>Deletion in B+ Tree</h3><a name="h3-10"></a></p><p><strong>Step 1:</strong> Delete the key and data from the leaves.</p><p><strong>Step 2:</strong> if the leaf node contains less than minimum number of elements, merge down the node with its sibling and delete the key in between them.</p><p><strong>Step 3:</strong> if the index node contains less than minimum number of elements, merge the node with the sibling and move down the key in between them.</p><p></p><p>Example</p><p>Delete the key 200 from the B+ Tree shown in the following figure.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-plus-tree-deletion.png"><img src="images/17-37.png" alt="images/17-37.png" /></a></p><p>200 is present in the right sub-tree of 190, after 195. delete it.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-plus-tree-deletion2.png"><img src="images/17-38.png" alt="images/17-38.png" /></a></p><p>Merge the two nodes by using 195, 190, 154 and 129.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-plus-tree-deletion3.png"><img src="images/17-39.png" alt="images/17-39.png" /></a></p><p>Now, element 120 is the single element present in the node which is violating the B+ Tree properties. Therefore, we need to merge it by using 60, 78, 108 and 120.</p><p>Now, the height of B+ tree will be decreased by 1.</p><p></p><p><a href="https://images.javatpoint.com/ds/images/b-plus-tree-deletion4.png"><img src="images/17-40.png" alt="images/17-40.png" /></a></p><p></p><p></p><p></p><p><h2>Heap Data Structure</h2><a name="h2-8"></a></p><p></p><p></p><p><h4>What is Heap?</h4><a name="h4-20"></a></p><p>A heap is a complete binary tree, and the binary tree is a tree in which the node can have utmost two children. Before knowing more about the heap <a href="https://www.javatpoint.com/data-structure-tutorial">data structure</a>, we should know about the complete binary tree.</p><p></p><p><h4>What is a complete binary tree?</h4><a name="h4-21"></a></p><p>A complete binary tree is a <a href="https://www.javatpoint.com/binary-tree">binary tree</a> in which all the levels except the last level, i.e., leaf node should be completely filled, and all the nodes should be left-justified.</p><p><strong><h4>Let&#39;s understand through an example.</h4></strong><a name="h4-22"></a></p><p><a href="https://images.javatpoint.com/ds/images/heap-data-structure.png"><img src="images/17-41.png" alt="images/17-41.png" /></a></p><p>In the above figure, we can observe that all the internal nodes are completely filled except the leaf node; therefore, we can say that the above tree is a complete binary tree.</p><p><a href="https://images.javatpoint.com/ds/images/heap-data-structure2.png"><img src="images/17-42.png" alt="images/17-42.png" /></a></p><p>The above figure shows that all the internal nodes are completely filled except the leaf node, but the leaf nodes are added at the right part; therefore, the above tree is not a complete binary tree.</p><p></p><p>Note: The heap tree is a special balanced binary tree data structure where the root node is compared with its children and arrange accordingly.</p><p></p><p>How can we arrange the nodes in the Tree?</p><p>There are two types of the heap:<ul><li>Min Heap</li><li>Max heap</li></ul></p><p></p><p><strong>Min Heap:</strong> The value of the parent node should be less than or equal to either of its children.</p><p><h3>Or</h3><a name="h3-11"></a></p><p>In other words, the min-heap can be defined as, for every node i, the value of node i is greater than or equal to its parent value except the root node. Mathematically, it can be defined as:</p><p><strong>A[Parent(i)] &lt;= A[i]</strong></p><p><strong>Let&#39;s understand the min-heap through an example.</strong></p><p><a href="https://images.javatpoint.com/ds/images/heap-data-structure3.png"><img src="images/17-43.png" alt="images/17-43.png" /></a></p><p>In the above figure, 11 is the root node, and the value of the root node is less than the value of all the other nodes (left child or a right child).</p><p><strong>Max Heap:</strong> The value of the parent node is greater than or equal to its children.</p><p><h3>Or</h3><a name="h3-12"></a></p><p>In other words, the max heap can be defined as for every node i; the value of node i is less than or equal to its parent value except the root node. Mathematically, it can be defined as:</p><p><strong>A[Parent(i)] &gt;= A[i]</strong></p><p><a href="https://images.javatpoint.com/ds/images/heap-data-structure4.png"><img src="images/17-44.png" alt="images/17-44.png" /></a></p><p>The above tree is a max heap tree as it satisfies the property of the max heap. Now, let&#39;s see the array representation of the max heap.</p><p></p><p><strong><h4>Time complexity in Max Heap</h4></strong><a name="h4-23"></a></p><p>The total number of comparisons required in the max heap is according to the height of the tree. The height of the complete binary tree is always logn; therefore, the time complexity would also be O(logn).</p><p></p><p><strong><h4>Algorithm of insert operation in the max heap.</h4></strong><a name="h4-24"></a></p><p></p><p><ol><li>// algorithm to insert an element in the max heap.  </li><li>insertHeap(A, n, value)  </li><li>{  </li><li>n=n+1; // n is incremented to insert the new element  </li><li>A[n]=value; // assign new value at the nth position  </li><li>i = n; // assign the value of n to i  </li><li>// loop will be executed until i becomes 1.   </li><li><strong><span style="color:#006699;">while</span></strong>(i&gt;1)   </li><li>{  </li><li>parent= floor value of i/2; // Calculating the floor value of i/2  </li><li>// Condition to check whether the value of parent is less than the given node or not   </li><li><strong><span style="color:#006699;">if</span></strong>(A[parent]&lt;A[i])   </li><li>{  </li><li>swap(A[parent], A[i]);  </li><li>i = parent;  </li><li>}  </li><li><strong><span style="color:#006699;">else</span></strong>  </li><li>{  </li><li><strong><span style="color:#006699;">return</span></strong>;  </li><li>}  </li><li>}  </li><li>}  </li></ol></p><p></p><p></p><p><strong>Let&#39;s understand the max heap through an example</strong>.</p><p>In the above figure, 55 is the parent node and it is greater than both of its child, and 11 is the parent of 9 and 8, so 11 is also greater than from both of its child. Therefore, we can say that the above tree is a max heap tree.</p><p><strong>Insertion in the Heap tree</strong></p><p><strong>44, 33, 77, 11, 55, 88, 66</strong></p><p>Suppose we want to create the max heap tree. To create the max heap tree, we need to consider the following two cases:<ul><li>First, we have to insert the element in such a way that the property of the complete binary tree must be maintained.</li><li>Secondly, the value of the parent node should be greater than the either of its child.</li></ul></p><p></p><p><strong>Step 1:</strong> First we add the 44 element in the tree as shown below:</p><p><a href="https://images.javatpoint.com/ds/images/heap-data-structure5.png"><img src="images/17-45.png" alt="images/17-45.png" /></a></p><p></p><p><strong>Step 2:</strong> The next element is 33. As we know that insertion in the binary tree always starts from the left side so 44 will be added at the left of 33 as shown below:</p><p></p><p><a href="https://images.javatpoint.com/ds/images/heap-data-structure6.png"><img src="images/17-46.png" alt="images/17-46.png" /></a></p><p></p><p></p><p><strong>Step 3:</strong> The next element is 77 and it will be added to the right of the 44 as shown below:</p><p></p><p><a href="https://images.javatpoint.com/ds/images/heap-data-structure7.png"><img src="images/17-47.png" alt="images/17-47.png" /></a></p><p></p><p>As we can observe in the above tree that it does not satisfy the max heap property, i.e., parent node 44 is less than the child 77. So, we will swap these two values as shown below:</p><p></p><p><a href="https://images.javatpoint.com/ds/images/heap-data-structure8.png"><img src="images/17-48.png" alt="images/17-48.png" /></a></p><p></p><p><strong>Step 4:</strong> The next element is 11. The node 11 is added to the left of 33 as shown below:</p><p></p><p><a href="https://images.javatpoint.com/ds/images/heap-data-structure9.png"><img src="images/17-49.png" alt="images/17-49.png" /></a></p><p></p><p><strong>Step 5:</strong> The next element is 55. To make it a complete binary tree, we will add the node 55 to the right of 33 as shown below:</p><p></p><p><a href="https://images.javatpoint.com/ds/images/heap-data-structure10.png"><img src="images/17-50.png" alt="images/17-50.png" /></a></p><p></p><p>As we can observe in the above figure that it does not satisfy the property of the max heap because 33&lt;55, so we will swap these two values as shown below:</p><p></p><p><a href="https://images.javatpoint.com/ds/images/heap-data-structure11.png"><img src="images/17-51.png" alt="images/17-51.png" /></a></p><p></p><p><strong>Step 6:</strong> The next element is 88. The left subtree is completed so we will add 88 to the left of 44 as shown below:</p><p></p><p><img src="images/17-52.png" alt="images/17-52.png" /></p><p></p><p>As we can observe in the above figure that it does not satisfy the property of the max heap because 44&lt;88, so we will swap these two values as shown below:</p><p></p><p>Again, it is violating the max heap property because 88&gt;77 so we will swap these two values as shown below:</p><p></p><p><strong>Step 7:</strong> The next element is 66. To make a complete binary tree, we will add the 66 element to the right side of 77 as shown below:</p><p>In the above figure, we can observe that the tree satisfies the property of max heap; therefore, it is a heap tree.</p><p></p><p><strong><h4>Deletion in Heap Tree</h4></strong><a name="h4-25"></a></p><p></p><p>In Deletion in the heap tree, the root node is always deleted and it is replaced with the last element.</p><p><strong>Let&#39;s understand the deletion through an example.</strong></p><p><strong>Step 1</strong>: In the above tree, the first 30 node is deleted from the tree and it is replaced with the 15 element as shown below:</p><p>Now we will heapify the tree. We will check whether the 15 is greater than either of its child or not. 15 is less than 20 so we will swap these two values as shown below:</p><p>Again, we will compare 15 with its child. Since 15 is greater than 10 so no swapping will occur.</p><p></p></div>
</body>
</html>
